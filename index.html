<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

	<title>Visual SHA-256 calculator</title>

	<link href="https://fonts.googleapis.com/css?family=Roboto+Mono:300,400" rel="stylesheet">
	<link rel="stylesheet" href="styles.css">

	<link rel="icon" href="fav.png" type="image/png">
</head>
<body>
	<div class="container">
		<h1>Visual SHA-256 calculator</h1>

		<h2>Enter your message here:</h2>

		<input type="text" id="message" value="Let's hash something!">

		<p class="note center">
			Bytes representation: <span data="bytemsg" class="bytes">&nbsp;</span>
		</p>

		<p class="note center">
			Resulting hash: <span data="hash" class="bytes">&nbsp;</span>
		</p>

		<h2>Step 1. Preparing the message.</h2>

		<p>
			Currently our message is <code data="len">&nbsp;</code> bits long (<code data="bytelen">&nbsp;</code> bytes). We need to append to the message its length in bits as a 64-bit integer and make the total length at least 512 bits long (64 bytes) or multiple of it. The length should be appended at the very end of the message. Right after the message we add one bit equal to 1 and then put zeros to make total length in bits multiple of 512.
		</p>

		<p class="important center">
			<span data="bytemsg" class="block bytes x16"></span>
			<span class="block">↓</span>
			<span data="normalized" class="block bytes x16"></span>
		</p>

		<p>
			Here gray bytes represent <span class="pad">padding</span> (additional bits to make the message length multiple of 64) and red bytes shows encoded <span class="len">length of the message in bits</span>.
		</p>

		<p>
			Now, when we have the message of correct length, we can finally start hashing.
		</p>

		<h2>Step 2. Initial hash values and round constants.</h2>

		<p>
			Output of any hashing function should look as random as possible. So it makes sense to add some randomness from the very beginning. In SHA-1 algorithm all initial values were chosen by NSA, who developed that algorithm (yes, for real). So people were thinking, what if NSA included some kind of backdoor in these constants to be able to get some information about the message just by looking at the hash?
		</p>

		<p>
			In SHA-256 initial hash values and round constants are much more transparent. They come from fractional parts of square and cubic roots of prime numbers.
		</p>

		<p>
			We will need 8 initial hash values <b>h</b> and 64 round constants <b>k</b>. <b>h</b> are taken from <b>square</b> roots of first 8 prime numbers, i.e. 2<sup>1/2</sup>, 3<sup>1/2</sup>, 5<sup>1/2</sup>, ..., 19<sup>1/2</sup>. <b>k</b> are taken from cubic roots of first 64 prime numbers, i.e. 2<sup>1/3</sup>, 3<sup>1/3</sup>, 5<sup>1/3</sup>, ..., 311<sup>1/3</sup>.
		</p>

		<div class="column">

			<p class="important center" id="h">
				<span class="block">
					<a id="nexth" class="noselect">←</a>
					<b>h<sub><span class="num">0</span></sub></b>
					<a id="prevh" class="noselect">→</a>
				</span>
				<span class="block bytes">
					<span class="prime">2</span><sup>1/2</sup>
				</span>
				<span class="block">↓</span>
				<span class="note">Decimal representation</span>
				<span class="block bytes dec">1.4142135623</span>
				<span class="block">↓</span>
				<span class="note">Fractional part</span>
				<span class="block bytes frac">0.4142135623</span>
				<span class="block">↓</span>
				<span class="note">HEX representation</span>
				<span class="block bytes hex">0.6a09e667</span>
				<span class="block">↓</span>
				<span class="note">Initial hash value</span>
				<span class="block bytes final">6A 09 E6 67</span>
			</p>

			<p class="important center" id="k">
				<span class="block">
					<a id="nextk" class="noselect">←</a>
					<b>k<sub><span class="num">0</span></sub></b>
					<a id="prevk" class="noselect">→</a>
				</span>
				<span class="block bytes">
					<span class="prime">2</span><sup>1/3</sup>
				</span>
				<span class="block">↓</span>
				<span class="note">Decimal representation</span>
				<span class="block bytes dec">1.2599210498</span>
				<span class="block">↓</span>
				<span class="note">Fractional part</span>
				<span class="block bytes frac">0.2599210498</span>
				<span class="block">↓</span>
				<span class="note">HEX representation</span>
				<span class="block bytes hex">0.428a2f98</span>
				<span class="block">↓</span>
				<span class="note">Round constant</span>
				<span class="block bytes final">42 8a 2f 98</span>
			</p>
		</div>

		<h2>Step 3. Chunks and rounds.</h2>

		<p>
			What we are going to do is the following:
		</p>
		<ol>
			<li>We split our message to 512 bits chunks.</li>
			<li>For each chunk we make 64 rounds of bitwise operations to change hash values <b>h</b>. For every round we use one of the round constants <b>k</b> that we generated earlier.</li>
		</ol>

		<p>
			In every round hash values change. For the first round of the first chunk we use initial hash values from Step 2. These rounds look a bit messy, but it is what you want to make the output as random as possible.
		</p>

		<h2>Step 3.1. Generating words for rounds.</h2>

		<p>
			Our chunk contains 512 bits and in every round we will work with 32-bit numbers. As we want to do 64 rounds, we need to generate 64 32-bit words from our chunk.
		</p>

		<p>
			If we split our chunk to 32-bit words, we will get 16 words. To generate the rest 48 words we use a combination of previous words:
		</p>

		<p class="center important">
	        w<sub>i</sub> = w<sub>i-16</sub> + s<sub>0</sub> + w<sub>i-7</sub> + s<sub>1</sub>
	    </p>
	    <p>Here s<sub>0</sub> and s<sub>1</sub> are calculated as follows:</p>
		<p class="center">
	        s<sub>0</sub> = (w<sub>i-15</sub> >>> 7) ⊕ (w<sub>i-15</sub> >>> 18) ⊕ (w<sub>i-15</sub> >> 3)
	    </p>
		<p class="center">
	        s<sub>1</sub> = (w<sub>i-2</sub> >>> 17) ⊕ (w<sub>i-2</sub> >>> 19) ⊕ (w<sub>i-2</sub> >> 10)
        </p>
	    <p> >>> means right rotation (circular shift of bits when bits are removed from the end of the word and prepended to the beginning), >> means right shift (last bits are removed, zeros are prepended). For example 100111<b>01</b> >>> 2 = <b>01</b>100111 and 10011101 >> 2 = <b>00</b>100111</p>

	</div>

	<script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>

	<script src="sha256.js"></script>
</body>
</html>