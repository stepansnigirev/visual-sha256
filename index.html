<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

	<title>Visual SHA-256 calculator</title>

	<link href="https://fonts.googleapis.com/css?family=Roboto+Mono:300,400" rel="stylesheet">
	<link rel="stylesheet" href="styles.css">

	<link rel="icon" href="fav.png" type="image/png">
</head>
<body>
	<div class="container">
		<h1>Visual SHA-256 calculator</h1>

		<h2>Enter your message here:</h2>

		<input type="text" id="message" value="Let's hash something!">

		<p class="note center">
			Bytes representation: <span data="bytemsg" class="bytes">&nbsp;</span>
		</p>

		<p class="note center">
			Resulting hash: <span data="hash" class="bytes">&nbsp;</span>
		</p>

		<h2>Step 1. Preparing the message.</h2>

		<p>
			Currently our message is <code data="len">&nbsp;</code> bits long (<code data="bytelen">&nbsp;</code> bytes). We need to append to the message its length in bits as a 64-bit integer and make the total length at least 512 bits long (64 bytes) or multiple of it. The length should be appended at the very end of the message. Right after the message we add one bit equal to 1 and then put zeros to make total length in bits multiple of 512.
		</p>

		<p class="important center">
			<span data="bytemsg" class="block bytes x16"></span>
			<span class="block">↓</span>
			<span data="normalized" class="block bytes x16"></span>
		</p>

		<p>
			Here <span class="pad">gray bytes</span> represent padding (additional bits to make the message length multiple of 64) and <span class="len">blue bytes</span> shows encoded length of the message.
		</p>

		<p>
			Now, when we have the message of correct length, we can finally start hashing.
		</p>

		<h2>Step 2. Initial constants.</h2>

		<p>
			Output of any hashing function should look as random as possible. So it makes sense to add some randomness from the very beginning. In SHA-1 algorithm initial values of all constants were chosen by NSA, who developed that algorithm (yes, for real). So people were thinking, what if NSA included some kind of backdoor in these constants to be able to get some information about the message just by looking at the hash?
		</p>

		<p>
			In SHA-256 initial values of the constants are much more transparent. Initial randomness is coming from square and cubic roots of first prime numbers.
		</p>

		<p>
			We will need two sets of 32-bit constants. They are usually called <b>h</b> and <b>k</b>. We will need 8 h-numbers and 64 k-numbers. <b>h-numbers</b> are taken from <b>square</b> roots of first 8 prime numbers, i.e. 2<sup>1/2</sup>, 3<sup>1/2</sup>, 5<sup>1/2</sup>, ..., 19<sup>1/2</sup>. <b>k-numbers</b> are cubic roots from first 64 prime numbers, i.e. 2<sup>1/3</sup>, 3<sup>1/3</sup>, 5<sup>1/3</sup>, ..., 311<sup>1/3</sup>.
		</p>

		<div class="column">

			<p class="important center" id="h">
				<span class="block">
					<a id="nexth" class="noselect">←</a>
					<b>h[<span class="num">0</span>]</b>
					<a id="prevh" class="noselect">→</a>
				</span>
				<span class="block bytes">
					<span class="prime">2</span><sup>1/2</sup>
				</span>
				<span class="block">↓</span>
				<span class="note">Decimal representation</span>
				<span class="block bytes dec">1.4142135623</span>
				<span class="block">↓</span>
				<span class="note">Fractional part</span>
				<span class="block bytes frac">0.4142135623</span>
				<span class="block">↓</span>
				<span class="note">HEX representation</span>
				<span class="block bytes hex">0.6a09e667</span>
				<span class="block">↓</span>
				<span class="note">Final value</span>
				<span class="block bytes final">6A 09 E6 67</span>
			</p>

			<p class="important center" id="k">
				<span class="block">
					<a id="nextk" class="noselect">←</a>
					<b>k[<span class="num">0</span>]</b>
					<a id="prevk" class="noselect">→</a>
				</span>
				<span class="block bytes">
					<span class="prime">2</span><sup>1/3</sup>
				</span>
				<span class="block">↓</span>
				<span class="note">Decimal representation</span>
				<span class="block bytes dec">1.2599210498</span>
				<span class="block">↓</span>
				<span class="note">Fractional part</span>
				<span class="block bytes frac">0.2599210498</span>
				<span class="block">↓</span>
				<span class="note">HEX representation</span>
				<span class="block bytes hex">0.428a2f98</span>
				<span class="block">↓</span>
				<span class="note">Final value</span>
				<span class="block bytes final">42 8a 2f 98</span>
			</p>
		</div>

		<h2>Step 3. Splitting the message into chunks.</h2>

		<p>
			Now we need to split our prepared message into chunks 512 bits each. In our case we have just one chunk. If data were longer we would need to repeat step 4 for every chunk, taking constants from previous chunk.
		</p>

	</div>

	<script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>

	<script src="sha256.js"></script>
</body>
</html>